# -*- coding: utf-8 -*-
"""TrabalhoFinalEstatisticaBim1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IcEBS2Z1TbpbQhibHJ25davOfy5NWwbq
"""

import pandas as pd
import requests
from bs4 import BeautifulSoup
import numpy as np
import math, random
import matplotlib.pyplot as plt
import bokeh
from bokeh.io import output_notebook
from bokeh.plotting import figure, show
from urllib.request import urlopen

print("Web Scrapping")
print("Indicadores de Desen0volvimento Mundial: Taxa de mortalidade infantil por 1.000 nascidos vivos - 2018")
print()

url = 'http://wdi.worldbank.org/table/2.18'
html = urlopen(url)

soup = BeautifulSoup(html.read(), 'html.parser')

tabela = soup.findAll('table', { 'class': 'indicators-table' })[1]

linhas = tabela.findAll('tr')

dict = {} 

for linha in linhas:
    pais = linha.find('td', { 'class': 'country' }).text
    mortalidade2018 = linha.findAll('td')[6].text #Coluna escolhida - mortalidade Infantil para cada 100 000 habitantes - 2018

    if not (mortalidade2018 == '..'): #Se tiver dados de mortalidade do ano 2018
        dict[pais] = float(mortalidade2018) 

# Ordenar crescente
lista_ordenada = sorted(dict, key=dict.get)
lista = []
df = pd.DataFrame(columns=["nome","qtd"])

    
#Exibir lista com País e quantitativo
for nome_do_pais in lista_ordenada:
    indice = lista_ordenada.index(nome_do_pais) + 1
    print(indice, nome_do_pais, dict[nome_do_pais])  #Exibindo a tabela organizadamente 
    df.loc[indice] = [nome_do_pais, dict[nome_do_pais]]
    

k = int(1 + 3.3 * math.log10(df.qtd.size)) #Número de Classes
minimo = int(df.qtd.min().min())
maximo = int(df.qtd.max().max())
print("Número de classes:", k)
print("Menor valor:", minimo)
print("Maior valor:", maximo)
print("Total de elementos: ", df.qtd.size)
h = math.ceil(float((maximo - minimo)/k)) #Intervalo de classes

minimo_classes = minimo #Classes (min |- min + h)
intervalo_classes=[]
print("Intervalo de classes/Amplitude:", h)
print()

for i in range (k):
    intervalo = ("%i |- %i" %(minimo_classes, minimo_classes+h))
    minimo_classes += h
    intervalo_classes.append(intervalo)


at = df.qtd.max()-df.qtd.min()

#k = raiz quadrada do total de registros/amostras
#O valor de amplitude de classe pode ser arredondado para um número inteiro, geralmente para facilitar a interpretação da tabela.

frequencias = []

# Menor valor da série
menor = round(df.qtd.min(),1) #1.0

# Menor valor somado a amplitude
menor_amp = round(menor+h,1) #12.0

valor = menor
while valor < df.qtd.max():
    frequencias.append('{} |- {}'.format(round(valor,1),round(valor+h,1)))
    valor += h

    
#Frequência Simples (fi)
freq_abs = pd.qcut(df.qtd,len(frequencias),labels=frequencias) # Discretização dos valores em k faixas, rotuladas pela lista criada anteriormente
fi = freq_abs.value_counts().sort_index()
freq_abs.value_counts().sort_index()



acumulada = freq_abs.value_counts().sort_index().cumsum()


#Frequência Relativa Simples (fri)
fri = freq_abs.value_counts(normalize=True).sort_index()


#Frequência Relativa Acumulada (Fri) (Fi/N) 
Fri = freq_abs.value_counts(normalize=True).sort_index().cumsum()


#Porcentagem
porc = freq_abs.value_counts(normalize=True).sort_index()*(100)


#Ângulo
ang = freq_abs.value_counts(normalize=True).sort_index().cumsum()*(360)


#Ponto Médio (xi)
freq = []
valor = menor
while valor < df.qtd.max():
    freq.append(((valor)+(valor+h))/2)
    valor += h  
xi = freq



#Xifi \n
xifi = freq_abs.value_counts().sort_index().cumsum()*freq



media_xi = freq_abs.value_counts().sort_index().cumsum()*freq
j = 0
for i in media_xi.values:
  j+=i
  
media = j/df.qtd.size


#xi - x\n
modulo = abs(freq-media)


#|xi-x|*fi\n
modulo2 = modulo*fi

#|xi-x|² *fi\n
quad = abs(modulo)*abs(modulo)
modulo3 = quad*fi.values

moda = df.qtd.mode()

# Mediana 
mediana = df.qtd.median()

# Variância
variancia = df.qtd.var()

#Desvio Padrão
desvio_padrao = df.qtd.std()


# Primeiro Quartil
primeiroquartil = df.qtd.quantile(0.25)

#print("Segundo Quartil \n")
segundoquartil = df.qtd.quantile(0.5)

#print("Terceiro Quartil \n")
terceiroquartil = df.qtd.quantile(0.75)


#Gráfico de Pizza
labels = intervalo_classes 
sizes = ang

fig1, ax1 = plt.subplots()
ax1.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90)
ax1.axis('equal')
plt.title('Ângulo\n')
plt.savefig('Angulo.png')


print()

#Histograma
activity = {"1 |- 12": 14.705882, "12 |- 23":13.725490, "23 |- 34":9.803922 , "34 |- 45": 12.254902, "45 |- 56:":13.235294, "56 |- 67":11.274510, "78 |- 89":12.745098, "78 |- 89": 12.25490}
names = list(activity.keys())
values = list(activity.values())

fig, axs = plt.subplots()
axs.bar(names, values)
fig.suptitle('Histograma')



data = {
    'fi': fi,
    'Fi': acumulada,
    'fri': fri,
    'Fri': Fri,
    '%': porc,
    'Ang': ang,
    'xi':freq,
    'xifi': xifi,
    '|xi-x|': modulo,
    '|xi-x|*fi': modulo2,
    '|xi-x^2|*fi': modulo3
}

table = pd.DataFrame(data)
table['media'] = ''
table['media'][0] = media
table

table['moda'] = ''
table['moda'][0] = moda[0]
table

table['mediana'] = ''
table['mediana'][0] = mediana
table

table['variancia'] = ''
table['variancia'][0] = variancia
table

table['Desvio padrao'] = ''
table['Desvio padrao'][0] = desvio_padrao
table

table['Primeiro Quartil'] = ''
table['Primeiro Quartil'][0] = primeiroquartil
table

table['Segundo Quartil'] = ''
table['Segundo Quartil'][0] = segundoquartil
table

table['Terceiro Quartil'] = ''
table['Terceiro Quartil'][0] = terceiroquartil
table
